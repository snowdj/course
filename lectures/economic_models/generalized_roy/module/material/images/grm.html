<html>
<head>
<title>grm.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { }
.s2 { color: rgb(0,0,128); font-weight: bold; }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
grm.py</FONT>
</center></TD></TR></TABLE>
<pre>

<span class="s0">&quot;&quot;&quot; This module all functions to process, simulate, and estimate a 
    generalized Roy model. 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s0"># Lexical Analysis</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">shlex 
 
</span><span class="s0"># Copy operations</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">copy 
 
</span><span class="s0"># Scientific Computing</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np 
</span><span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">norm 
</span><span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">minimize 
 
 
</span><span class="s3">''' Process '''</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">process(file_): 
    </span><span class="s0">&quot;&quot;&quot; This function reads the init.ini file. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0"># Initialization</span><span class="s1"> 
    dict_ = {} 
 
    </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">open(file_).readlines(): 
 
        list_ = shlex.split(line) 
 
        </span><span class="s0"># Determine special cases</span><span class="s1"> 
        is_empty, is_keyword = _process_cases(list_) 
 
        </span><span class="s0"># Applicability</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">is_empty: 
            </span><span class="s2">continue</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">is_keyword: 
            keyword = list_[</span><span class="s4">0</span><span class="s1">] 
            dict_[keyword] = {} 
            </span><span class="s2">continue</span><span class="s1"> 
 
        </span><span class="s0"># Distribute information</span><span class="s1"> 
        name, val = list_[</span><span class="s4">0</span><span class="s1">], list_[</span><span class="s4">1</span><span class="s1">] 
 
        </span><span class="s0"># Prepare container.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">dict_[keyword].keys(): 
 
            </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'coeff'</span><span class="s1">]: 
                dict_[keyword][name] = [] 
 
        </span><span class="s0"># Type conversion</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'agents'</span><span class="s1">, </span><span class="s3">'maxiter'</span><span class="s1">]: 
            val = int(val) 
        </span><span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'file'</span><span class="s1">, </span><span class="s3">'optimizer'</span><span class="s1">, </span><span class="s3">'start'</span><span class="s1">, </span><span class="s3">'version'</span><span class="s1">]: 
            val = str(val) 
        </span><span class="s2">else</span><span class="s1">: 
            val = float(val) 
 
        </span><span class="s0"># Collect information</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'coeff'</span><span class="s1">]: 
            dict_[keyword][name] += [val] 
        </span><span class="s2">else</span><span class="s1">: 
            dict_[keyword][name] = val 
 
    </span><span class="s0"># Add auxiliary objects</span><span class="s1"> 
    dict_ = _add_auxiliary(dict_) 
 
    </span><span class="s0"># Check quality.</span><span class="s1"> 
    _check_integrity_process(dict_) 
 
    </span><span class="s0"># Finishing.</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">dict_ 
 
 
</span><span class="s2">def </span><span class="s1">_check_integrity_process(dict_): 
    </span><span class="s0">&quot;&quot;&quot; Check integrity of initFile dict. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(dict_, dict)) 
 
    </span><span class="s0"># Check number of agents</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(dict_[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'agents'</span><span class="s1">] &gt; </span><span class="s4">0</span><span class="s1">) 
    </span><span class="s2">assert </span><span class="s1">(isinstance(dict_[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'agents'</span><span class="s1">], int)) 
 
    </span><span class="s0"># Check optimizer</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(dict_[</span><span class="s3">'ESTIMATION'</span><span class="s1">][</span><span class="s3">'optimizer'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'bfgs'</span><span class="s1">, </span><span class="s3">'nm'</span><span class="s1">]) 
 
    </span><span class="s0"># Check starting values</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(dict_[</span><span class="s3">'ESTIMATION'</span><span class="s1">][</span><span class="s3">'start'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'random'</span><span class="s1">, </span><span class="s3">'init'</span><span class="s1">]) 
 
    </span><span class="s0"># Maximum iterations</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(dict_[</span><span class="s3">'ESTIMATION'</span><span class="s1">][</span><span class="s3">'maxiter'</span><span class="s1">] &gt;= </span><span class="s4">0</span><span class="s1">) 
 
    </span><span class="s0"># Finishing</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">True 
 
 
</span><span class="s2">def </span><span class="s1">_add_auxiliary(dict_): 
    </span><span class="s0">&quot;&quot;&quot; Add some auxiliary objects. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(dict_, dict)) 
 
    </span><span class="s0"># Initialize container</span><span class="s1"> 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">] = {} 
 
    </span><span class="s0"># Full set of coefficients.</span><span class="s1"> 
    dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = [dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'int'</span><span class="s1">]] 
    dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] += dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">] 
    dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = np.array(dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">]) 
 
    dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = [dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'int'</span><span class="s1">]] 
    dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] += dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">] 
    dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = np.array(dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">]) 
 
    dict_[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = np.array(dict_[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">]) 
 
    </span><span class="s0"># Number of covariates</span><span class="s1"> 
    num_covars_out = len(dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">]) + </span><span class="s4">1</span><span class="s1"> 
    num_covars_cost = len(dict_[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">]) 
 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_covars_out'</span><span class="s1">] = num_covars_out 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_covars_cost'</span><span class="s1">] = num_covars_cost 
 
    </span><span class="s0"># Number of parameters</span><span class="s1"> 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_paras'</span><span class="s1">] = </span><span class="s4">2 </span><span class="s1">* num_covars_out + num_covars_cost + </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1"> 
 
    </span><span class="s0"># Starting values</span><span class="s1"> 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] = [] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += [dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'int'</span><span class="s1">]] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += [dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'int'</span><span class="s1">]] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += dict_[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += [dict_[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">]] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += [dict_[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">]] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += [dict_[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'treated'</span><span class="s1">]] 
    dict_[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">] += [dict_[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'untreated'</span><span class="s1">]] 
 
    </span><span class="s0"># Finishing</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">dict_ 
 
 
</span><span class="s2">def </span><span class="s1">_process_cases(list_): 
    </span><span class="s0">&quot;&quot;&quot; Process cases and determine whether keyword or empty 
        line. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(list_, list)) 
 
    </span><span class="s0"># Get information</span><span class="s1"> 
    is_empty = (len(list_) == </span><span class="s4">0</span><span class="s1">) 
 
    </span><span class="s2">if not </span><span class="s1">is_empty: 
        is_keyword = list_[</span><span class="s4">0</span><span class="s1">].isupper() 
    </span><span class="s2">else</span><span class="s1">: 
        is_keyword = False 
 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(is_keyword </span><span class="s2">in </span><span class="s1">[True, False]) 
    </span><span class="s2">assert </span><span class="s1">(is_empty </span><span class="s2">in </span><span class="s1">[True, False]) 
 
    </span><span class="s0"># Finishing</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">is_empty, is_keyword 
 
</span><span class="s3">''' Simulate '''</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">simulate(init_dict, unobserved=False): 
    </span><span class="s0">&quot;&quot;&quot; Simulate a model based on the initialization file. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(init_dict, dict)) 
    </span><span class="s2">assert </span><span class="s1">(unobserved </span><span class="s2">in </span><span class="s1">[True, False]) 
 
    </span><span class="s0"># Ensure recomputability</span><span class="s1"> 
    np.random.seed(</span><span class="s4">123</span><span class="s1">) 
 
    </span><span class="s0"># Distribute information</span><span class="s1"> 
    num_agents = init_dict[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'agents'</span><span class="s1">] 
    file_name = init_dict[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'file'</span><span class="s1">] 
 
    Y1_coeffs = init_dict[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] 
    Y0_coeffs = init_dict[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] 
 
    C_coeffs = np.array(init_dict[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'coeff'</span><span class="s1">]) 
 
    U1_var = init_dict[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
    U0_var = init_dict[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
 
    V_var = init_dict[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
 
    U1V_rho = init_dict[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'treated'</span><span class="s1">] 
    U0V_rho = init_dict[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'untreated'</span><span class="s1">] 
 
    </span><span class="s0"># Auxiliary objects</span><span class="s1"> 
    U1V_cov = U1V_rho * np.sqrt(U1_var) * np.sqrt(V_var) 
    U0V_cov = U0V_rho * np.sqrt(U0_var) * np.sqrt(V_var) 
 
    num_covars_out = Y1_coeffs.shape[</span><span class="s4">0</span><span class="s1">] 
    num_covars_cost = C_coeffs.shape[</span><span class="s4">0</span><span class="s1">] 
 
    </span><span class="s0"># Simulate observables</span><span class="s1"> 
    means = np.tile(</span><span class="s4">0.0</span><span class="s1">, num_covars_out) 
    covs = np.identity(num_covars_out) 
 
    X = np.random.multivariate_normal(means, covs, num_agents) 
    X[:, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1.0</span><span class="s1"> 
 
    means = np.tile(</span><span class="s4">0.0</span><span class="s1">, num_covars_cost) 
    covs = np.identity(num_covars_cost) 
 
    Z = np.random.multivariate_normal(means, covs, num_agents) 
 
    </span><span class="s0"># Construct index of observable characteristics</span><span class="s1"> 
    Y1_level = np.dot(Y1_coeffs, X.T) 
    Y0_level = np.dot(Y0_coeffs, X.T) 
    C_level = np.dot(C_coeffs, Z.T) 
 
    </span><span class="s0"># Simulate unobservables</span><span class="s1"> 
    means = np.tile(</span><span class="s4">0.0</span><span class="s1">, </span><span class="s4">3</span><span class="s1">) 
    vars_ = [U1_var, U0_var, V_var] 
    covs = np.diag(vars_) 
 
    covs[</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">] = U1V_cov 
    covs[</span><span class="s4">2</span><span class="s1">, </span><span class="s4">0</span><span class="s1">] = covs[</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">] 
 
    covs[</span><span class="s4">1</span><span class="s1">, </span><span class="s4">2</span><span class="s1">] = U0V_cov 
    covs[</span><span class="s4">2</span><span class="s1">, </span><span class="s4">1</span><span class="s1">] = covs[</span><span class="s4">1</span><span class="s1">, </span><span class="s4">2</span><span class="s1">] 
 
    U = np.random.multivariate_normal(means, covs, num_agents) 
 
    </span><span class="s0"># Simulate endogenous variables</span><span class="s1"> 
    Y1 = np.tile(np.nan, num_agents) 
    Y0 = np.tile(np.nan, num_agents) 
    Y = np.tile(np.nan, num_agents) 
 
    D = np.tile(np.nan, num_agents) 
 
    </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_agents): 
 
        </span><span class="s0"># Select individual unobservables and observables</span><span class="s1"> 
        u1, u0, v = U[i, </span><span class="s4">0</span><span class="s1">], U[i, </span><span class="s4">1</span><span class="s1">], U[i, </span><span class="s4">2</span><span class="s1">] 
 
        y1_idx, y0_idx, c_idx = Y1_level[i], Y0_level[i], C_level[i] 
 
        </span><span class="s0"># Decision Rule</span><span class="s1"> 
        expected_benefits = y1_idx - y0_idx 
        cost = c_idx + v 
 
        d = np.float((expected_benefits - cost &gt; </span><span class="s4">0</span><span class="s1">)) 
 
        </span><span class="s0"># Potential outcomes</span><span class="s1"> 
        y1, y0 = y1_idx + u1, y0_idx + u0 
 
        </span><span class="s0"># Observed outcomes</span><span class="s1"> 
        y = d * y1 + (</span><span class="s4">1.0 </span><span class="s1">- d) * y0 
 
        </span><span class="s0"># Collect data matrices</span><span class="s1"> 
        Y[i], Y0[i], Y1[i], D[i] = y, y1, y0, d 
 
    </span><span class="s0"># Check integrity of simulated data</span><span class="s1"> 
    _check_integrity_simulate(Y1, Y0, Y, D) 
 
    </span><span class="s0"># Save to disk</span><span class="s1"> 
    _write_out(Y, D, X, Z, file_name, unobserved, Y1, Y0) 
 
    </span><span class="s0"># Return selected features of data</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">Y1, Y0, D 
 
 
</span><span class="s2">def </span><span class="s1">_check_integrity_simulate(Y1, Y0, Y, D): 
    </span><span class="s0">&quot;&quot;&quot; Check quality of simulated sample. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(np.all(np.isfinite(Y1))) 
    </span><span class="s2">assert </span><span class="s1">(np.all(np.isfinite(Y0))) 
 
    </span><span class="s2">assert </span><span class="s1">(np.all(np.isfinite(Y))) 
    </span><span class="s2">assert </span><span class="s1">(np.all(np.isfinite(D))) 
 
    </span><span class="s2">assert </span><span class="s1">(Y1.dtype == </span><span class="s3">'float'</span><span class="s1">) 
    </span><span class="s2">assert </span><span class="s1">(Y0.dtype == </span><span class="s3">'float'</span><span class="s1">) 
 
    </span><span class="s2">assert </span><span class="s1">(Y.dtype == </span><span class="s3">'float'</span><span class="s1">) 
    </span><span class="s2">assert </span><span class="s1">(D.dtype == </span><span class="s3">'float'</span><span class="s1">) 
 
    </span><span class="s2">assert </span><span class="s1">(D.all() </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1.0</span><span class="s1">, </span><span class="s4">0.0</span><span class="s1">]) 
 
 
</span><span class="s2">def </span><span class="s1">_write_out(Y, D, X, Z, file_name, unobserved=False, Y1=None, Y0=None): 
    </span><span class="s0">&quot;&quot;&quot; Write out simulated data to file. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">if not </span><span class="s1">unobserved: 
 
        np.savetxt(file_name, np.column_stack((Y, D, X, Z)), fmt=</span><span class="s3">'%8.3f'</span><span class="s1">) 
 
    </span><span class="s2">else</span><span class="s1">: 
 
        </span><span class="s2">assert </span><span class="s1">(isinstance(Y1, np.ndarray)) 
        </span><span class="s2">assert </span><span class="s1">(isinstance(Y0, np.ndarray)) 
 
        np.savetxt(file_name, np.column_stack((Y, D, X, Z, Y1, Y0)), 
                   fmt=</span><span class="s3">'%8.3f'</span><span class="s1">)\ 
 
 
</span><span class="s3">''' Estimate '''</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">estimate(init_dict): 
    </span><span class="s0">&quot;&quot;&quot; Estimate our version of the generalized Roy model. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(init_dict, dict)) 
 
    </span><span class="s0"># Load dataset</span><span class="s1"> 
    Y, D, X, Z = _load_data(init_dict) 
 
    </span><span class="s0"># Create auxiliary objects</span><span class="s1"> 
    start = init_dict[</span><span class="s3">'ESTIMATION'</span><span class="s1">][</span><span class="s3">'start'</span><span class="s1">] 
    maxiter = init_dict[</span><span class="s3">'ESTIMATION'</span><span class="s1">][</span><span class="s3">'maxiter'</span><span class="s1">] 
 
    optimizer = init_dict[</span><span class="s3">'ESTIMATION'</span><span class="s1">][</span><span class="s3">'optimizer'</span><span class="s1">] 
    num_covars_out = init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_covars_out'</span><span class="s1">] 
 
    </span><span class="s0"># Initialize different starting values</span><span class="s1"> 
    x0 = _get_start(start, init_dict) 
 
    </span><span class="s0"># Select optimizer</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">optimizer == </span><span class="s3">'nm'</span><span class="s1">: 
 
        optimizer = </span><span class="s3">'Nelder-Mead'</span><span class="s1"> 
 
    </span><span class="s2">elif </span><span class="s1">optimizer == </span><span class="s3">'bfgs'</span><span class="s1">: 
 
        optimizer = </span><span class="s3">'BFGS'</span><span class="s1"> 
 
    </span><span class="s0"># Provide additional arguments to the optimizer</span><span class="s1"> 
    opts = dict() 
 
    opts[</span><span class="s3">'maxiter'</span><span class="s1">] = maxiter 
 
    </span><span class="s0"># Run optimization or just evaluate function at starting values</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">maxiter == </span><span class="s4">0</span><span class="s1">: 
 
        </span><span class="s0"># Collect maximization arguments.</span><span class="s1"> 
        rslt = _distribute_parameters(np.array(x0), init_dict, num_covars_out) 
 
        </span><span class="s0"># Calculate likelihood according to user's request</span><span class="s1"> 
        likl = _negative_log_likelihood(rslt, Y, D, X, Z) 
 
        </span><span class="s0"># Compile results</span><span class="s1"> 
        x_rslt, fun, success = x0, likl, False 
 
    </span><span class="s2">else</span><span class="s1">: 
 
        </span><span class="s0"># Check out the SciPy documentation for details about the interface</span><span class="s1"> 
        </span><span class="s0"># to the `minimize' function that provides a convenient interface to</span><span class="s1"> 
        </span><span class="s0">#  a variety of alternative maximization algorithms. You will also</span><span class="s1"> 
        </span><span class="s0"># find information about the return information.</span><span class="s1"> 
        opt_rslt = minimize(_max_interface, x0, args=(Y, D, X, Z, init_dict), 
                            method=optimizer, options=opts) 
 
        </span><span class="s0"># Compile results</span><span class="s1"> 
        x_rslt, fun = opt_rslt[</span><span class="s3">'x'</span><span class="s1">], opt_rslt[</span><span class="s3">'fun'</span><span class="s1">] 
        success = opt_rslt[</span><span class="s3">'success'</span><span class="s1">] 
 
    </span><span class="s0"># Tranformation to internal parameters</span><span class="s1"> 
    rslt = _distribute_parameters(x_rslt, init_dict, num_covars_out) 
 
    rslt[</span><span class="s3">'fval'</span><span class="s1">], rslt[</span><span class="s3">'success'</span><span class="s1">] = fun, success 
 
    </span><span class="s0"># Finishing</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">rslt 
 
 
</span><span class="s2">def </span><span class="s1">_distribute_parameters(x, init_dict, num_covars_out): 
    </span><span class="s0">&quot;&quot;&quot; Distribute the parameters. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(x, np.ndarray)) 
    </span><span class="s2">assert </span><span class="s1">(isinstance(num_covars_out, int)) 
    </span><span class="s2">assert </span><span class="s1">(num_covars_out &gt; </span><span class="s4">0</span><span class="s1">) 
 
    </span><span class="s0"># Initialize containers</span><span class="s1"> 
    rslt = dict() 
 
    rslt[</span><span class="s3">'TREATED'</span><span class="s1">] = dict() 
    rslt[</span><span class="s3">'UNTREATED'</span><span class="s1">] = dict() 
    rslt[</span><span class="s3">'COST'</span><span class="s1">] = dict() 
    rslt[</span><span class="s3">'RHO'</span><span class="s1">] = dict() 
 
    </span><span class="s0"># Distribute parameters</span><span class="s1"> 
    rslt[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = x[:num_covars_out] 
    rslt[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = x[num_covars_out:(</span><span class="s4">2 </span><span class="s1">* num_covars_out)] 
 
    rslt[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">] = x[(</span><span class="s4">2 </span><span class="s1">* num_covars_out):(-</span><span class="s4">4</span><span class="s1">)] 
    rslt[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] = init_dict[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
 
 
    rslt[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] = np.exp(x[(-</span><span class="s4">4</span><span class="s1">)]) 
    rslt[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] = np.exp(x[(-</span><span class="s4">3</span><span class="s1">)]) 
 
    rslt[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'treated'</span><span class="s1">] = -</span><span class="s4">1.0 </span><span class="s1">+ </span><span class="s4">2.0 </span><span class="s1">/ (</span><span class="s4">1.0 </span><span class="s1">+ float(np.exp(-x[-</span><span class="s4">2</span><span class="s1">]))) 
    rslt[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'untreated'</span><span class="s1">] = -</span><span class="s4">1.0 </span><span class="s1">+ </span><span class="s4">2.0 </span><span class="s1">/ (</span><span class="s4">1.0 </span><span class="s1">+ float(np.exp(-x[-</span><span class="s4">1</span><span class="s1">]))) 
 
    </span><span class="s0"># Update auxiliary versions</span><span class="s1"> 
    rslt[</span><span class="s3">'AUX'</span><span class="s1">] = dict() 
 
    rslt[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'x_internal'</span><span class="s1">] = x.copy() 
    rslt[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'x_internal'</span><span class="s1">][-</span><span class="s4">4</span><span class="s1">] = np.exp(x[(-</span><span class="s4">4</span><span class="s1">)]) 
    rslt[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'x_internal'</span><span class="s1">][-</span><span class="s4">3</span><span class="s1">] = np.exp(x[(-</span><span class="s4">3</span><span class="s1">)]) 
    rslt[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'x_internal'</span><span class="s1">][-</span><span class="s4">2</span><span class="s1">] = -</span><span class="s4">1.0 </span><span class="s1">+ </span><span class="s4">2.0 </span><span class="s1">/ (</span><span class="s4">1.0 </span><span class="s1">+ float(np.exp(-x[-</span><span class="s4">2</span><span class="s1">]))) 
    rslt[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'x_internal'</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">] = -</span><span class="s4">1.0 </span><span class="s1">+ </span><span class="s4">2.0 </span><span class="s1">/ (</span><span class="s4">1.0 </span><span class="s1">+ float(np.exp(-x[-</span><span class="s4">1</span><span class="s1">]))) 
 
    </span><span class="s0"># Finishing.</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">rslt 
 
 
</span><span class="s2">def </span><span class="s1">_max_interface(x, Y, D, X, Z,init_dict): 
    </span><span class="s0">&quot;&quot;&quot; Interface to the SciPy maximization routines. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Auxiliary objects</span><span class="s1"> 
    num_covars_out = X.shape[</span><span class="s4">1</span><span class="s1">] 
 
    </span><span class="s0"># Collect maximization arguments</span><span class="s1"> 
    rslt = _distribute_parameters(x, init_dict, num_covars_out) 
 
    </span><span class="s0"># Calculate likelihood</span><span class="s1"> 
    likl = _negative_log_likelihood(rslt, Y, D, X, Z) 
 
    </span><span class="s0"># Finishing.</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">likl 
 
 
</span><span class="s2">def </span><span class="s1">_negative_log_likelihood(args, Y, D, X, Z): 
    </span><span class="s0">&quot;&quot;&quot; Negative log-likelihood evaluation. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Distribute parametrization</span><span class="s1"> 
    Y1_coeffs = np.array(args[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">]) 
    Y0_coeffs = np.array(args[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">]) 
    C_coeffs = np.array(args[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'all'</span><span class="s1">]) 
 
    U1_var = args[</span><span class="s3">'TREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
    U0_var = args[</span><span class="s3">'UNTREATED'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
 
    var_V = args[</span><span class="s3">'COST'</span><span class="s1">][</span><span class="s3">'var'</span><span class="s1">] 
 
    U1V_rho = args[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'treated'</span><span class="s1">] 
    U0V_rho = args[</span><span class="s3">'RHO'</span><span class="s1">][</span><span class="s3">'untreated'</span><span class="s1">] 
 
    </span><span class="s0"># Auxiliary objects.</span><span class="s1"> 
    U1_sd = np.sqrt(U1_var) 
    U0_sd = np.sqrt(U0_var) 
    V_sd = np.sqrt(var_V) 
 
    num_agents = Y.shape[</span><span class="s4">0</span><span class="s1">] 
    choice_coeffs = np.concatenate((Y1_coeffs - Y0_coeffs, - C_coeffs)) 
 
    </span><span class="s0"># Initialize containers</span><span class="s1"> 
    likl = np.tile(np.nan, num_agents) 
    choice_idx = np.tile(np.nan, num_agents) 
 
    </span><span class="s0"># Likelihood construction.</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_agents): 
 
        G = np.concatenate((X[i, :], Z[i, :])) 
        choice_idx[i] = np.dot(choice_coeffs, G) 
 
        </span><span class="s0"># Select outcome information</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">D[i] == </span><span class="s4">1.00</span><span class="s1">: 
 
            coeffs, rho, sd = Y1_coeffs, U1V_rho, U1_sd 
        </span><span class="s2">else</span><span class="s1">: 
            coeffs, rho, sd = Y0_coeffs, U0V_rho, U0_sd 
 
        arg_one = (Y[i] - np.dot(coeffs, X[i, :])) / sd 
        arg_two = (choice_idx[i] - rho * V_sd * arg_one) / \ 
                  np.sqrt((</span><span class="s4">1.0 </span><span class="s1">- rho ** </span><span class="s4">2</span><span class="s1">) * var_V) 
 
        pdf_evals, cdf_evals = norm.pdf(arg_one), norm.cdf(arg_two) 
 
        </span><span class="s2">if </span><span class="s1">D[i] == </span><span class="s4">1.0</span><span class="s1">: 
            contrib = (</span><span class="s4">1.0 </span><span class="s1">/ float(sd)) * pdf_evals * cdf_evals 
        </span><span class="s2">else</span><span class="s1">: 
            contrib = (</span><span class="s4">1.0 </span><span class="s1">/ float(sd)) * pdf_evals * (</span><span class="s4">1.0 </span><span class="s1">- cdf_evals) 
 
        likl[i] = contrib 
 
    </span><span class="s0"># Transformations.</span><span class="s1"> 
    likl = -np.mean(np.log(np.clip(likl, </span><span class="s4">1e-20</span><span class="s1">, np.inf))) 
 
    </span><span class="s0"># Quality checks.</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(likl, float)) 
    </span><span class="s2">assert </span><span class="s1">(np.isfinite(likl)) 
 
    </span><span class="s0"># Finishing.</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">likl 
 
 
</span><span class="s2">def </span><span class="s1">_load_data(init_dict): 
    </span><span class="s0">&quot;&quot;&quot; Load dataset. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Auxiliary objects</span><span class="s1"> 
    num_covars_out = init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_covars_out'</span><span class="s1">] 
    num_covars_cost = init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_covars_cost'</span><span class="s1">] 
    num_agents = init_dict[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'agents'</span><span class="s1">] 
 
    </span><span class="s0"># Read dataset</span><span class="s1"> 
    data = np.genfromtxt(init_dict[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'file'</span><span class="s1">]) 
 
    </span><span class="s0"># Reshaping, this ensure that the program also runs with just one agent</span><span class="s1"> 
    </span><span class="s0"># as otherwise only an vector is created. This creates problems for the</span><span class="s1"> 
    </span><span class="s0"># subsetting of the overall data into the components.</span><span class="s1"> 
    data = np.array(data, ndmin=</span><span class="s4">2</span><span class="s1">) 
 
    </span><span class="s0"># Distribute data</span><span class="s1"> 
    Y, D = data[:, </span><span class="s4">0</span><span class="s1">], data[:, </span><span class="s4">1</span><span class="s1">] 
 
    X, Z = data[:, </span><span class="s4">2</span><span class="s1">:(num_covars_out + </span><span class="s4">2</span><span class="s1">)], data[:, -num_covars_cost:] 
 
    </span><span class="s0"># Finishing</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">Y, D, X, Z 
 
 
</span><span class="s2">def </span><span class="s1">_get_start(which, init_dict): 
    </span><span class="s0">&quot;&quot;&quot; Get different kind of starting values. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging.</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(which </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'random'</span><span class="s1">, </span><span class="s3">'init'</span><span class="s1">]) 
 
    </span><span class="s0"># Distribute auxiliary objects</span><span class="s1"> 
    num_paras = init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_paras'</span><span class="s1">] 
 
    </span><span class="s0"># Select relevant values.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">which == </span><span class="s3">'random'</span><span class="s1">: 
        x0 = np.random.uniform(size=num_paras) 
 
        </span><span class="s0"># Variances</span><span class="s1"> 
        x0[(-</span><span class="s4">4</span><span class="s1">)] = max(x0[(-</span><span class="s4">4</span><span class="s1">)], </span><span class="s4">0.01</span><span class="s1">) 
        x0[(-</span><span class="s4">3</span><span class="s1">)] = max(x0[(-</span><span class="s4">3</span><span class="s1">)], </span><span class="s4">0.01</span><span class="s1">) 
 
        </span><span class="s0"># Correlations</span><span class="s1"> 
        x0[(-</span><span class="s4">2</span><span class="s1">)] -= </span><span class="s4">0.5</span><span class="s1"> 
        x0[(-</span><span class="s4">1</span><span class="s1">)] -= </span><span class="s4">0.5</span><span class="s1"> 
 
    </span><span class="s2">elif </span><span class="s1">which == </span><span class="s3">'init'</span><span class="s1">: 
        x0 = np.array(init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'init_values'</span><span class="s1">][:]) 
    </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s2">raise </span><span class="s1">AssertionError 
 
    </span><span class="s0"># Document starting values</span><span class="s1"> 
    init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'start_values'</span><span class="s1">] = x0.copy() 
 
    </span><span class="s0"># Transform to real line</span><span class="s1"> 
    x0 = _transform_start(x0) 
 
    </span><span class="s0"># Type conversion</span><span class="s1"> 
    x0 = np.array(x0) 
 
    </span><span class="s0"># Quality assurance.</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(np.all(np.isfinite(x0))) 
 
    </span><span class="s0"># Finishing.</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">x0 
 
 
</span><span class="s2">def </span><span class="s1">_transform_start(x): 
    </span><span class="s0">&quot;&quot;&quot; Transform starting values to cover the whole real line. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0"># Coefficients</span><span class="s1"> 
    x[:(-</span><span class="s4">4</span><span class="s1">)] = x[:(-</span><span class="s4">4</span><span class="s1">)] 
 
    </span><span class="s0"># Variances</span><span class="s1"> 
    x[(-</span><span class="s4">4</span><span class="s1">)] = np.log(x[(-</span><span class="s4">4</span><span class="s1">)]) 
    x[(-</span><span class="s4">3</span><span class="s1">)] = np.log(x[(-</span><span class="s4">3</span><span class="s1">)]) 
 
    </span><span class="s0"># Correlations</span><span class="s1"> 
    transform = (x[(-</span><span class="s4">2</span><span class="s1">)] + </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1"> 
    x[(-</span><span class="s4">2</span><span class="s1">)] = np.log(transform / (</span><span class="s4">1.0 </span><span class="s1">- transform)) 
 
    transform = (x[(-</span><span class="s4">1</span><span class="s1">)] + </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1"> 
    x[(-</span><span class="s4">1</span><span class="s1">)] = np.log(transform / (</span><span class="s4">1.0 </span><span class="s1">- transform)) 
 
    </span><span class="s0"># Finishing</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">x 
 
 
</span><span class="s3">''' Inspect '''</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">inspect(rslt, init_dict): 
    </span><span class="s0">&quot;&quot;&quot; This function simulates a sample from the estimates of the model 
        and reports the average effects of treatment in a file. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0"># Antibugging</span><span class="s1"> 
    </span><span class="s2">assert </span><span class="s1">(isinstance(rslt, dict)) 
    </span><span class="s2">assert </span><span class="s1">(isinstance(init_dict, dict)) 
 
    </span><span class="s0"># Update results</span><span class="s1"> 
    modified_init = copy.deepcopy(init_dict) 
 
    </span><span class="s2">for </span><span class="s1">key_ </span><span class="s2">in </span><span class="s1">rslt.keys(): 
 
        </span><span class="s2">if </span><span class="s1">key_ </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'fval'</span><span class="s1">, </span><span class="s3">'success'</span><span class="s1">]: 
            </span><span class="s2">continue</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">subkey </span><span class="s2">in </span><span class="s1">rslt[key_].keys(): 
 
            modified_init[key_][subkey] = rslt[key_][subkey] 
 
    </span><span class="s0"># Modified dataset</span><span class="s1"> 
    modified_init[</span><span class="s3">'BASICS'</span><span class="s1">][</span><span class="s3">'file'</span><span class="s1">] = </span><span class="s3">'simulated.grm.txt'</span><span class="s1"> 
 
    </span><span class="s0"># Simulate from estimation results</span><span class="s1"> 
    Y1, Y0, D = simulate(modified_init, True) 
 
    </span><span class="s0"># Calculate the average treatment effects</span><span class="s1"> 
    B = Y1 - Y0 
 
    effects = [] 
    effects += [np.mean(B)] 
    effects += [np.mean(B[D == </span><span class="s4">1</span><span class="s1">])] 
    effects += [np.mean(B[D == </span><span class="s4">0</span><span class="s1">])] 
 
    </span><span class="s0"># Print selected results to file</span><span class="s1"> 
    </span><span class="s2">with </span><span class="s1">open(</span><span class="s3">'results.grm.txt'</span><span class="s1">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">file_: 
 
        file_.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3"> softEcon: Generalized Roy Model'</span><span class="s1">) 
        file_.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3"> -------------------------------</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) 
 
        </span><span class="s0"># Average effects of treatment</span><span class="s1"> 
        fmt = </span><span class="s3">'     {0:&lt;5}{1:10.2f}</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s1"> 
 
        file_.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3"> Average Treatment Effects</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s1">) 
 
        </span><span class="s2">for </span><span class="s1">i, label </span><span class="s2">in </span><span class="s1">enumerate([</span><span class="s3">'ATE'</span><span class="s1">, </span><span class="s3">'TT'</span><span class="s1">, </span><span class="s3">'TUT'</span><span class="s1">]): 
 
            str_ = fmt.format(label, effects[i]) 
 
            file_.write(str_) 
 
        file_.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3"> Parameters</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s1">) 
        file_.write(</span><span class="s3">'     Start    Finish</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s1">) 
 
        num_paras = init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'num_paras'</span><span class="s1">] 
 
        </span><span class="s0"># Structural parameters</span><span class="s1"> 
        x0, x = init_dict[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'start_values'</span><span class="s1">], rslt[</span><span class="s3">'AUX'</span><span class="s1">][</span><span class="s3">'x_internal'</span><span class="s1">] 
 
        fmt = </span><span class="s3">'{0:10.2f}{1:10.2f}</span><span class="s2">\n</span><span class="s3">'</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_paras): 
 
            str_ = fmt.format(x0[i], x[i]) 
 
            file_.write(str_) 
</span></pre>
</body>
</html>